# Cross Site Request Forgery (CSRF)

https://testdriven.io/blog/csrf-flask/
https://github.com/testdrivenio/csrf-example


Межсайтовая подделка запроса (CSRF) - это атака, которая заставляет конечного пользователя выполнять нежелательные действия в веб-приложении, в котром он в настоящее время, аутентицифиорован.

CSRF (Cross-Site Request Forgery) - это тип атак на веб-приложения, при котором злоумышленник может выполнить некоторые действия от имени аутентифицированного пользователя.

Пример  -> Пользователь авторизирован на сайте банка. Пользователь, открыл новую вкладку и начал просматривать сообщения в социальной сети. Случайно прешел по фишинговой сылке с котиком. Эта сылка с котиком включает запрос  на перевод денег  на аккаунт мошенника.

Методы HTTP которые подвержены CSRF.

GET, HEAD, OPTIONS, TRACE -   Методы  не подвежены CSRF, эти методы предназначены только для получения информации и не изменяют состояние сервера.

POST, PUT, DELETE и PATCH  - Методы должны быть защищены от CSRF.


Атака  ->

В приложении должно быть действие(фунцкия), которую зломышленник может использовать. К примеру изменить пароль, перевести средства и так далее.

Действие может быть выполнено с помощью  HTTP-запросов, и оно полагаеться только на файлы cookie, чтобы убедиться, что запрос исходит от пользователя.

CSRF могут быть подвергнуты веб-приложения использующие cookies, браузерную аутентификацию или клиентские сертификаты авторизации. По сути, CSRF подвержены все веб-приложения, которые автоматически добавляют аутентификационные данные пользователя к запросу.

Защита.

Выбрать защищенный фрэймворк 
Anti-CSRF токены

Токены (или synchronizer token) — это способ защиты со стороны сервера. Сервер генерирует случайный уникальный токен для браузера пользователя и проверяет его для каждого запроса.

Токен находится в скрытом поле, должен быть непредсказуемым случайным числом и иметь небольшое время жизни, без возможности переиспользования.

Токен должен удовлетворять следующим условиям:

-   быть уникальным в пределах каждой операции;
-   использоваться один раз;
-   иметь размер устойчивый к подбору;
-   генерироваться криптографически стойким генератором псевдослучайных чисел;
-   иметь ограниченное время жизни.

### Использование двух токенов

Смысл этого метода в том, что используются два токена: первый сохраняется в cookies, а второй — в одном из параметров ответа.

В таком случае сервер, получая один из небезопасных запросов, должен проверить оба токена.


### Использование флага Same-Site в сookies

[Этот флаг](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite) помечает куки для определенного домена.

Таким образом проверяется источник запроса, и его не получится выполнить с мошеннического сайта.

Этот флаг поддерживает большинство браузеров. Его стоит использовать как часть общей стратегии защиты от CSRF атак.



```Python
from flask import Flask, render_template, request, redirect

app = Flask(__name__)

# Симуляция страницы авторизации
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        # Проверяем, что пользователь ввел правильный пароль
        if request.form.get('password') == 'password':
            # Симулируем успешную авторизацию, устанавливаем cookie с идентификатором сессии и перенаправляем на защищенную страницу
            response = redirect('/dashboard')
            response.set_cookie('session_id', 'qwerty123')
            return response
        else:
            return 'Неверный пароль'
    else:
        return render_template('login.html')

# Защищенная страница, которая может быть изменена посредством атаки CSRF
@app.route('/dashboard', methods=['GET', 'POST'])
def dashboard():
    if request.method == 'POST':
        # Получаем новое сообщение и сохраняем его в базе данных
        new_message = request.form.get('message')
        # здесь должен быть код для сохранения нового сообщения
        return 'Сообщение сохранено'
    else:
        # Получаем идентификатор сессии из cookie
        session_id = request.cookies.get('session_id')
        # Проверяем, что пользователь авторизован
        if session_id == 'qwerty123':
            # Выводим форму для изменения сообщения
            return render_template('dashboard.html')
        else:
            return redirect('/login')

if __name__ == '__main__':
    app.run()

```


Защита 

1.  Защита с использованием проверки заголовка Referer: В этом случае сервер проверяет заголовок Referer в запросе, чтобы убедиться, что запрос пришел с правильного источника. Если заголовок Referer не содержит ожидаемое значение, сервер может решить, что запрос является CSRF-атакой и отклонить его. Пример кода на Python:

```Python
@app.route('/dashboard', methods=['POST'])
def dashboard():
    if request.method == 'POST':
        expected_referer = 'https://example.com/dashboard'
        if request.headers.get('Referer') != expected_referer:
            abort(403)  # ошибка доступа
        # обработка данных
        return render_template('dashboard.html')

```


2.  Защита с использованием токена CSRF: В этом случае на каждой странице формируется уникальный токен CSRF, который включается в форму в виде скрытого поля. При отправке формы клиент отправляет этот токен вместе с данными формы. Сервер проверяет, что токен в запросе соответствует ожидаемому значению, и только тогда обрабатывает данные. Пример кода на Python:

```Python
from flask_wtf.csrf import CSRFProtect
csrf = CSRFProtect(app)

@app.route('/dashboard', methods=['POST'])
@csrf.exempt # отключаем CSRF-защиту для примера
def dashboard():
    if request.method == 'POST':
        form_token = request.form.get('csrf_token')
        if not form_token or form_token != session.pop('_csrf_token', None):
            abort(403)  # ошибка доступа
        # обработка данных
        return render_template('dashboard.html')

```

Здесь мы используем библиотеку Flask-WTF для генерации токена CSRF и его включения в форму. Защита CSRF включается в приложение с помощью декоратора `csrf.exempt`. Затем мы проверяем, что токен, отправленный в запросе, соответствует ожидаемому значению, хранящемуся в сессии. Если токены не совпадают, мы отклоняем запрос с ошибкой доступа.

В обоих случаях используется защита на уровне приложения, которая помогает защитить приложение от CSRF-атак. Однако, при использовании токена CSRF, необходимо убедиться, что токен создается достаточно случайным образом и что он не может быть предсказан злоумышленником. Кроме того, рекомендуется использовать HTTPS для защиты передачи токена CSRF между клиентом и сервером.